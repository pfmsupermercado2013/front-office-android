package com.supermarket_frontoffice.recorrido_optimo.supermarket_map;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.ShortBuffer;
import javax.microedition.khronos.opengles.GL10;


/** @class Clase quedibuja la estantería del supermercado
 * 
 * @author fjvegaf
 *
 */
public class Estanteria 
{

	
	private float m_Longitud;
	private float m_Altura;
	private float m_Achura;
	private float m_AchuraBorde;
	
	private float m_YRotate;
	
	//private GLEstanteriaExample m_GLEstanteriaExample;
	
	
//	//Nuestros Vertices
//	private float vertices[] = {
//		-1f, -1f, 0f,	 
//		1f, -1f, 0f,	 
//		0f, 0.8f, 0f,	 
//		0f,  0f, 2f	 
//	};
//	 
//	// Definimos los vértices de nuestra pirámide en (x,y,z)
//	// La forma como vamos a conectarlos
//	 
//	private short caras[] = { 
//		0,1,2,	 
//		0,2,3,	 
//		0,1,4,	 
//		1,2,4,	 
//		2,3,4,	 
//		3,0,4	 
//	};
	
	private float vertices[];
	private short caras[];
	private float colors[];
	
	
	// Definimos los vértices de nuestra pirámide en (x,y,z)
	// La forma como vamos a conectarlos
	 
//	private short caras[] = { 
//		0,1, 3, 2
//		//1,2,3
//
//	};
	 
	//Definimos que vértices vamos a unir formando las caras triangulares
	 
//	private float colors[] = {
//		0.7f, 0.7f, 0.7f, 1.f,  
//		0.7f, 0.7f, 0.7f, 1.f,  
//		0.9f, 0.9f, 0.9f, 1.f,  
//		0.9f, 0.9f, 0.9f, 1.f,
////		1f, 1f, 1f, 1f,	  
////		1.f, 1.f, 1.f, 1f,	
////		1f, 0f, 0f, 1f,	 
////		0f, 1f, 0f, 1f,	 
////		0f, 0f, 1f, 1f,	 
////		1f, 0f, 1f, 1f
//	};
	 
	//Definimos los colores que vamos a utilizar en cada vertice
	 
	private FloatBuffer vertexBuffer;	 
	private FloatBuffer colorBuffer;	 
	private ShortBuffer indexBuffer;
	
	private FloatBuffer vertexBufferExample;	
	private FloatBuffer vertexNormalsExample;
	private FloatBuffer vertexTexCoordsExample;	
	
	
	/** Constructor
	 * 
	 */
	public Estanteria( ) 
	{
		this( 100.f, 45.f, 55.f, 5.f );
	}
	
	/** Constructor
	 * 
	 */
	public Estanteria( float a_Longitud, float a_Altura, float a_Achura, float a_AchuraBorde ) 
	{
	 
		
		m_Longitud= a_Longitud / 100.f;
		m_Altura= a_Altura / 100.f;
		m_Achura= a_Achura / 100.f;
		m_AchuraBorde= a_AchuraBorde / 100.f;
		

		m_YRotate= 0.f;
		
		
//		// Nuestros Vertices
//		vertices = new float[]{
//				0.f, 0.f, 0.f,
//				m_Achura/100.f, 0.f, 0.f,	
//				m_Achura/100.f, 0.f, -m_Longitud / 100.f,	
//				0.f, 0.f, -m_Longitud / 100.f
//		};
		
		// Nuestros Vertices
		vertices = new float[]{
				0.f, 			0.f, 			0.f,	// V0
				m_Achura, 		0.f, 			0.f,	// V1
				m_Achura, 	    m_AchuraBorde, 	0.f,	// V2
				m_AchuraBorde,  m_AchuraBorde, 	0.f,	// V3
				m_AchuraBorde,  m_Altura, 		0.f,	// V4
				0.f, 			m_Altura, 		0.f,	// V5
				
				0.f, 			0.f, 			-m_Longitud,	// V6
				m_Achura, 		0.f, 			-m_Longitud,	// V7
				m_Achura, 	    m_AchuraBorde, 	-m_Longitud,	// V8
				m_AchuraBorde,  m_AchuraBorde, 	-m_Longitud,	// V9
				m_AchuraBorde,  m_Altura, 		-m_Longitud,	// V10
				0.f, 			m_Altura, 		-m_Longitud,	// V11
				 
		};
		
		// Definimos los vértices de nuestra pirámide en (x,y,z)
		// La forma como vamos a conectarlos
		caras= new short[] { 
				1, 2, 0, 3,
				5, 4,
				11, 10,
				6, 9, 
				7, 8,
				1, 2,
				3, 8, 9, 
				3, 4, 9, 10
				//10, 3, 
			//	3, 9, 4, 10,
//				0, 1, 3, 2,
//				9, 8,
//				6, 7,
//				2, 1,
				//4, 5,
				//1,2,3

		};
		
		//Definimos que vértices vamos a unir formando las caras triangulares
		colors= new float[]{
				0.7f, 0.7f, 0.7f, 1.f,  
				0.7f, 0.7f, 0.7f, 1.f,  
				0.7f, 0.7f, 0.7f, 1.f,  
				0.7f, 0.7f, 0.7f, 1.f, 
				0.7f, 0.7f, 0.7f, 1.f,  
				0.7f, 0.7f, 0.7f, 1.f, 
				
				0.9f, 0.9f, 0.9f, 1.f,  
				0.9f, 0.9f, 0.9f, 1.f,
				0.9f, 0.9f, 0.9f, 1.f,  
				0.9f, 0.9f, 0.9f, 1.f,
				0.9f, 0.9f, 0.9f, 1.f,  
				0.9f, 0.9f, 0.9f, 1.f,
//				1f, 1f, 1f, 1f,	  
//				1.f, 1.f, 1.f, 1f,	
//				1f, 0f, 0f, 1f,	 
//				0f, 1f, 0f, 1f,	 
//				0f, 0f, 1f, 1f,	 
//				1f, 0f, 1f, 1f
			};
		
		
//		// un float es de 4 bytes, por lo que multiplicaremos el numero de vertices por 4 
//		ByteBuffer vbb= ByteBuffer.allocateDirect( vertices.length * 4 );
//		 
//		vbb.order(ByteOrder.nativeOrder());	 
//		vertexBuffer = vbb.asFloatBuffer();	 
//		vertexBuffer.put(vertices);	 
//		vertexBuffer.position(0);
//		 
//		// un short es de 2 bytes, por lo que multiplicaremos el numero de vertices por 2 
//		ByteBuffer ibb = ByteBuffer.allocateDirect(caras.length * 2);
//		 
//		ibb.order(ByteOrder.nativeOrder());	 
//		indexBuffer = ibb.asShortBuffer();	 
//		indexBuffer.put(caras);	 
//		indexBuffer.position(0);
//		 
//		ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length * 4);	 
//		cbb.order(ByteOrder.nativeOrder());	 
//		colorBuffer = cbb.asFloatBuffer();	 
//		colorBuffer.put(colors);
//		 
//		colorBuffer.position(0);
		
//				
//		// un float es de 4 bytes, por lo que multiplicaremos el numero de vertices por 4 
//		ByteBuffer vbb= ByteBuffer.allocateDirect( m_m_GLEstanteriaExample.m_EstanteriaVerts.length * 4 );
//		 
//		vbb.order(ByteOrder.nativeOrder());	 
//		vertexBufferExample = vbb.asFloatBuffer();	 
//		vertexBufferExample.put( m_GLEstanteriaExample.m_EstanteriaVerts );	 
//		vertexBufferExample.position(0);
//		 
//		// un short es de 2 bytes, por lo que multiplicaremos el numero de vertices por 2 
//		ByteBuffer ibb = ByteBuffer.allocateDirect( m_GLEstanteriaExample.m_EstanteriaNormals.length * 4 );
//		 
//		ibb.order(ByteOrder.nativeOrder());	 
//		vertexNormalsExample = ibb.asFloatBuffer();	 
//		vertexNormalsExample.put(m_GLEstanteriaExample.m_EstanteriaNormals);	 
//		vertexNormalsExample.position(0);
//		 
//		ByteBuffer cbb = ByteBuffer.allocateDirect( m_GLEstanteriaExample.m_EstanteriaTexCoords.length * 4);	 
//		cbb.order(ByteOrder.nativeOrder());	 
//		vertexTexCoordsExample = cbb.asFloatBuffer();	 
//		vertexTexCoordsExample.put(colors);
//		 
//		vertexTexCoordsExample.position(0);
		
		
		
		
	} // end Estanteria
	
	
	public void draw( GL10 a_Gl ) {
		 
		
		
//		a_Gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBufferExample );
//		a_Gl.glNormalPointer( GL10.GL_FLOAT, 0, vertexNormalsExample );
//		a_Gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, vertexTexCoordsExample );
//
//		// draw data
//		a_Gl.glDrawArrays( GL10.GL_TRIANGLES, 0, m_GLEstanteriaExample.m_Estanteria_NumVerts );
//		
//		
//		
		
		//
		return;
		
//		
//		a_Gl.glRotatef( m_YRotate, 0, 1, 0 );
//		
//		m_YRotate+= 4.f;
//		
//		// Contra las agujas del reloj		 
//		a_Gl.glFrontFace(GL10.GL_CCW);
//		 
//		// Habilitar el sacrificio de caras a ocultar		 
//		a_Gl.glEnable(GL10.GL_CULL_FACE);
//		 
//		// Aca se indica que cara se sacrificara, en este caso, la de atras		 
//		a_Gl.glCullFace(GL10.GL_BACK);
//		 
//		// Habilitar el buffer de vertices para la escritura y cuales se usaran para el renderizado
//		a_Gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
//		 
//		// Especifica la localizacion y el formato de los datos de un array de vertices a utilizar para el renderizado
//		a_Gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBuffer);
//		
//		 
//		// Habilita el buffer para el color del grafico		 
//		a_Gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
//		 
//		// Señala donde se encuentra el buffer del color		 
//		a_Gl.glColorPointer(4, GL10.GL_FLOAT, 0, colorBuffer);
//		 
//		//Dibujamos las superficies		 
//		a_Gl.glDrawElements( GL10.GL_TRIANGLE_STRIP, caras.length, GL10.GL_UNSIGNED_SHORT, indexBuffer );
//		 
//		// Desactiva el buffer de los vertices		 
//		a_Gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
//		 
//		//Desactiva la caracteristica de sacrificios de las caras		 
//		a_Gl.glDisable(GL10.GL_CULL_FACE);
//		 
//		// Desahilita el buffer del color		 
//		a_Gl.glDisableClientState(GL10.GL_COLOR_ARRAY);      
		
		
		
	} // end draw
		 
	
	
} // // End class Estanteria
